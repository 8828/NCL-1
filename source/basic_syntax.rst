基础语法
========================
许多的NCL初学者都通过学习范例的形式来开始NCL的学习，一些人甚至不屑于去看语法知识。
这样难免造成后续的一些恶果，经常是程序执行出行异常，却不知是何原因，事实上都是忽
视语法学习的后果。

NCL的语言十分简洁，甚至可以说有些简陋，所以学习起来并不十分费劲。我想大概也就是
几个小时的时间，就能让你有个较为全面的理解。

NCL语言特点
------------------
动态类型语言
^^^^^^^^^^^^^^
相较于编译型语言，脚本解释性语言通常设计的比较灵活，NCL也不例外。动态类型语言也
就是说，你不要在赋值一个变量前声明变量的类型，当你赋值后，NCL解释器将自动根据值
的类型来确定变量类型。常见的动态类型语言还有Python、Ruby，或者你在用的Matlab。

强类型语言
^^^^^^^^^^^^^^^
NCL同时还是强类型语言，也就是说一旦变量类型确定，除强制转换类型外，你无法改变变
量的类型。因此强类型语言是类型安全的语言。显而易见，强类型语言的在类型上的严谨性
能够有效的避免许多错误。

________________________________________________________________________________

NCL数据类型
-----------------------
基本上，NCL的数据类型可以分为两类，一类为数值类型（numeric），另一类则是非数值类
型（Non-numeric）。

数值类型
^^^^^^^^^^^^^^^^
数值类型说白点就是常用的整数、浮点数（或许你叫小数），也是在各类语言中都存在的基
本类型。numeric类型下面分属的各种类型支持NCL中所有的代数函数。由于NCL的数据结构参
照NetCDF，随着NetCDF中数据类型的改变，NCL在5.2.0版本中也增添了几种数值类型（int64，
uint64，ulong，uint，ushort，ubyte）以保持与NetCDF数据结构的同步。为了保持向后的兼容性，
NCL有增加了两个关键词，分别是enumeric (extra-numeric)和snumeric (super-numeric)，
前者（enumeric）特指新增加的这几种类型，而后者则指代所有的数值型，包括最初的numeric
和新增加的enumeric。这些关键词通常出现在函数和程序定义的形参类型制定中。对于初学
者而言，这些复杂的内部细节尚不需要完全知悉，稍作了解即可。

**整型**，也就是整数，当你在NCL命令行中输入 :code:`a = 1` ，此时变量a就被定义为
一个整型变量，值为1。你可以通过 :code:`print(a)` 来查看变量的类型。你在shell中看
到的应该是这样的一个输出::

    Variable: a  ; 这里指示输出的变量名为a
    Type: integer  ; 这里指示变量a类型为整型
    Total Size: 4 bytes ; 这里指示变量a占用的内存大小为4个字节
                1 values  ; 这里指示变量a总共有1个值
    Number of Dimensions: 1  ; 这里指示变量a的维数为1维
    Dimensions and sizes:   [1]  ; 这里指示变量a的每一维的大小，第一维上只有一个值 
    Coordinates:  ; 这里表示变量a的坐标，此时并没有坐标，所以空着
    (0) 1  ; 这里打印变量a的每一个值，和值的索引序号

.. note:: 你可能很好奇，为什么简单的打印一个变量会出来这么多东西。实际上这是因为NCL变量参照NetCDF模型，所以一个变量确定后就自动地拥有了维数、大小、坐标等等。这种我们称之为 **元数据** 的东西，在绘制图形型显得尤为重要。目前，你还不需要完全知悉这些细节。

事实上，整型数据涵盖的子类型较广泛，依据所占的内存大小，可以排列为

+------------+------------+-----------------+------------+
|   类型     |  类型大小  |    名称         |  文字后缀  |
+============+============+=================+============+
|  int64     | 64位/6字节 |  64位整型       |      q     |
+------------+------------+-----------------+------------+
|  uint64    | 64位/6字节 |  64位无符号整型 |      Q     |
+------------+------------+-----------------+------------+
|  long      | 32位| 64位 |  长整型         |      l     |
+------------+------------+-----------------+------------+
|  ulong     | 32位| 64位 |  无符号长整型   |      L     |
+------------+------------+-----------------+------------+
|  integer   | 32位/4字节 |  整型           |   i (可选) |
+------------+------------+-----------------+------------+
|  uinteger  | 32位/4字节 |  无符号整型     |      I     |
+------------+------------+-----------------+------------+
|  short     | 16位/2字节 |  短整型         |      h     |
+------------+------------+-----------------+------------+
|  ushort    | 16位/2字节 |  无符号短整型   |      H     |
+------------+------------+-----------------+------------+
|  byte      | 8位/1字节  |  字节型         |      b     |
+------------+------------+-----------------+------------+
|  ubyte     | 8位/1字节  |  无符号字节型   |      B     |
+------------+------------+-----------------+------------+

**浮点型**，也就是小数，依据所占内存大小分为单精度（32位）和双精度浮点数（64位）。
对于浮点数的直接赋值定义不仅可以使用小数点，如 :code:`a = 0.11` ；同时也可以使用
科学记数法，如 :code:`b = 1.2E-2` ，注意这里的 **E** 也可以用小写的 **e** 替代。

+------------+------------+----------------+------------+
|   类型     |  类型大小  |    名称        |  文字后缀  |
+============+============+================+============+
|  double    | 64位/6字节 |  双精度浮点数  |    d或D    |
+------------+------------+----------------+------------+
|  float     | 32位/4字节 |  单精度浮点数  |     无     |
+------------+------------+----------------+------------+

通常而言，我们不需要关心这么多具体的数据类型，因为你会发现最常用的只有
:code:`integer` 和 :code:`float` 这两种。只有在考虑设计数据结构或者读取的二进制
数据时，你才能接触到这些恼人的东西。比如当你读取的一个NetCDF文件变量，而有时你会
发现这个变量的类型竟是 :code:`short` ，此时你可能就需要做做转换了。


非数值类型
^^^^^^^^^^^^^^^^
非数值类型指的是那些没有数值的且不能被转换到数值的类型。所以一般来说非数值型只能
支持等于或者不等于的逻辑运算。有两个特殊的情况是，加号 :code:`+` 运算符在字符串
类型中被重载为字符串连接算符；而逻辑型支持所有的逻辑运算符。非数值类型有以下，

+------------+------------+----------------+
|   类型     |  类型大小  |    名称        |
+============+============+================+
|  logical   |    N/A     |    逻辑型      |
+------------+------------+----------------+
|  string    |    N/A     |    字符串型    |
+------------+------------+----------------+
| character  |  8位/1字节 |    字符型      |
+------------+------------+----------------+
|  graphic   |    N/A     |     图形       |
+------------+------------+----------------+
|    file    |    N/A     |     文件       |
+------------+------------+----------------+
|    list    |    N/A     |     列（链）表 |
+------------+------------+----------------+

**逻辑型**，也就是你可能熟悉的真（ :code:`True` ）或假（ :code:`False`），有点不
同的是，NCL中加强了对缺测值的处理操作，所以在逻辑类型中新增了一个值 **缺测** （
:code:`Missing` ）。对于逻辑运算的知识会在稍后介绍。

**字符串型**，即变长字符串，如 :code:`a = "My name is wqshen"` 。字符串的值是用
双引号 **""** （英文输入法哦）引起来一段字符。比较可惜的是NCL并不支持Unicode编码，
这使得其在中文文本处理和绘制包含中文的图形上受到了很大限制。
值得注意的是，NCL中的字符串类型是可变长度的。这意味着，你在定义一个字符串变量后
可重新赋值一个不等长度的字符串而并不引发异常。
    需要认真提到的是，你必须使用双引号来定义字符串，单引号是不被允许的。并且NCL
    中并没有转义字符，这多少会带来一些麻烦，比如你的字符串中本身包含双引号。官方
    提出的办法是你可以使用函数 :code:`str_get_dq` 或者 :code:`tochar(34)` 来生成
    一个引号，并用 :code:`+` 来连接，比如
    
    .. code::

    dq = str_get_dq()
    a = "My name is "+dq+"wqshen"+dq 。

**字符型**，要在NCL中直接赋值定义一个字符变量并不是件容易的事情，你必须使用字符
对应的ASCII值并才上 **C** 后缀来实现。一个更人性化的方法是使用函数 :code:`tochar`
或者在6.0.0版本以下，你可能需要使用 :code:`stringtocharacter`。比如创建一个 *c*
字符你可以 :code:`a = 99C` 或者 :code:`a = tochar("c")`。


**图形**，指的是HLU对象的实例。图形类型的值额可以是creat语句，HLU函数和getValues
语句的返回。在实际的应用中，通常我们使用的是预定义的图形函数，特别是对于普通用户
而言，创建自定义图形变量或获取图形变量编程基本不会被用到。

**文件**，值得是NCL直接支持的文件，使用函数 :code:`addfile` 的返回值的类型就是文
件。

**列表**，相当于一个容器，可以支持任何类型对象。然而，目前来看NCL中的列表类型能
提供的用途还很鸡肋。大多数情况下，你很少去定义列表变量，通常是在你不自觉的情况下，
使用到的。比如使用函数 :code:`addfiles` 读取多个文件，其返回的就是一个文件列表。

________________________________________________________________________________

NCL数组
-----------------------
数组是NCL中贯穿始终的概念，也是NCL代码高效工作的基础。一些从Fortran转过来的学习
者可能需要暂时放下循环思维，重新理解NCL的数组思维对于提高编写的代码质量是至关重
要的。

定义数组
^^^^^^^^^^^^^^^^^
大体上，有三种方式可以创建NCL数组，分别的数组的直接定义、new语句（注意不是函数）
和其他数组创建函数。

**直接定义**
    数组创建以数组定义符 :code:`(/` 和 :code:`/)` 封闭所有元素，元素之间以逗号
    :code:`,` 进行分隔。多维数组创建通过嵌套数组定义符即可。数组元素既可以包含标
    量值，也可以包括其他数组。数组可以被建立为任何的基本类型以及图形对象。当前文
    件数组（包含文件变量的数组）并不被支持。数组中以逗号分隔的每一个元素必须和其
    它元素有相同的大小。另外，如果数组元素彼此类型不同时，类型转换规则将被应用，
    将数组元素转换为同一类型，如果类型转换失败，NCL将抛出异常。

    下面是几个直接定义数组范例::

        (/1, 2, 3, 4, 5/)  ; 创建一维整型数组
        (/ (/1, 2, 3/)^2, (/4, 5, 6/)^3, (/7, 8, 9/)^4/) ; 创建3*3的二维整型数组
        (/ a - b, b + c,  c/d /)  ; 以变量创建数组

    需要注意的一点是，如果将变量置于数组定义符  :code:`(/` 和 :code:`/)`
    内，只有变量的值会被引用，而与变量相关的元数据（后面会细述），包括属性、维和
    坐标都将丢失。

**new语句**
    相比于直接定义，在某些情况下，比如我想创建一个高维数组，并且将所有的值初始化
    为0，那么可能就要用到new语句了。new语句使用起来有点像Fortran的带大小的数组变
    量声明。

    new语句包含的参数：
    
    - 维数大小，可以是数组或标量
    - 类型，任意数据类型，可用引号括起类型关键词，但常直接使用关键词
    - 缺测值，可选参数，无缺测也可使用 :code:`No_FillValue` ，省略时使用类型默认

    几个范例::

        a = new( (/ 5, 6, 7 /), float)  ; 创建一个5*6*7大小的三维浮点型数组
        b = new( (/ 5, 6, 7 /), short, -999)  ; 设置默认缺测为-999
        c = new( (/ 5, 6, 7 /), integer, "No_FillValue")  ; 设定没有缺测值

    实用技巧
        在我们定义一个数组的大小和类型的时候，我们常常会参考到其他变量。比如我想
        创建与某个变量同样维数、大小的数组，怎么操作呢？其实搭配一些函数，
        :code:`new` 语句将会好用的多。

        .. code::

            m = new((/5,6,7/), integer, -999)
            n = new(dimsizes(m), string)  ; 搭配dimsizes函数可以定义同样大小的数组
            p = new(10, typeof(n))  ; 使用typeof函数就可以定义与n同样类型的数组变量
            q = new(10, typeof(n), m@_FillValue)  ; 使用第三个参数则可定义同样缺测值的数组变量
            x = n  ; 可能直接用另一个变量赋值是最有效的方式

    需要认真声明一点，尽管使用起来很像，但 :code:`new`并不是一个函数，而是NCL语
    句，这意味在 :code:`new` 语句中可以使用NCL关键词，比如 :code:`graphic` 。

**其他数组创建函数**

________________________________________________________________________________

NCL变量
-----------------------
变量是NCL语言中极具特色的部分。了解NCL变量看起来是必须的，也是最根本的。

变量命名规则
^^^^^^^^^^^^^^
变量名必须以字母或下划线（*并没有特殊含义*）开始，可由任意的字母、数字和下划线构
成。注意变量名是大小写敏感的，也就是说一个大写的变量名和相同内容小写的变量名并不
是同一个东西。目前变量名最大支持256个字符，相信不是有特殊需求的完全是够用了。

+------------------+------------------+
|   合法的变量名   |   非法的变量名   |
+==================+==================+
|  a               |  3a *数字开头*   |
+------------------+------------------+
|  forecast_time   |  a.b *包含符号*  |
+------------------+------------------+
|  __s092389       |  if *使用关键字* |
+------------------+------------------+

元数据
^^^^^^^^^^^^^^
NCL变量可以有辅助信息，称之为元数据。元数据是从属于变量的。这些元数据与NetCDF数据
结构十分相似，因此NCL变量模型就是参照NetCDF数据模型设计的。它们可以分为三类，
**属性** ，**维** 和 **坐标** ，下面将会一一介绍。

属性
^^^^^^^^


维
^^^^^^^^^


坐标
^^^^^^^^^^

NCL表达式
-----------------------


NCL语句
-----------------------


NCL关键字
-----------------------