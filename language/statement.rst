NCL语句
===========

语句是NCL的基本元素，只有在语句被输入后NCL才会开始执行。
语句并不限定于单行代码，可以嵌套。
在NCL中有17中不同类型的语句，分别是：

- 赋值语句
- 程序调用语句
- 函数定义语句
- 程序定义语句
- block代码块语句
- do语句
- if-then语句
- if-then-else语句
- break语句
- continue语句
- setvalues语句
- return语句
- record语句
- new语句
- stop语句
- quit语句

代码块语句
-----------------
代码块语句提供的是打包命令的列表的功能。因为代码块是语句，
因此在 ``begin`` 和 ``end`` 之间的语句在 ``end`` 语句被解
析前都不会被执行，并且这些代码段内的语句将被检查是否是语法
正确的。封装在一个代码块中的脚本被NCL解释器解析，如果没有
语法错误，将被执行。当通过向NCL载入脚本或管道脚本的方式使
用NCL时，应该使用代码块 ``begin`` 和 ``end`` 。这将使得语
法错误在被执行前发现，而不是在执行的时候。

模型：::

    begin
        statement list
    end

赋值语句
-----------
赋值语句用于将任何类型的值赋值给变量、变量的切片、坐标变量
和属性。除此之外，赋值语句也被用于将字符串值复制给维名称。
若干个NCL语法构造被用于确定将会发生什么类型的赋值。

- ``=>`` 文件组赋值
- ``->`` 文件变量赋值
- ``!`` 维名称赋值
- ``&`` 坐标变量赋值
- ``@`` 属性赋值

在没有这些构造的赋值语句中，使用 *普通的值到变量赋值* 。

下面将分别介绍这些不同的赋值语句的语法。
:ref:`variableAssignment` 给出了变量的赋值语法，其涵盖了变量到变量
的赋值。变量到变量的赋值不仅仅会拷贝所有的变量的值，而且也拷贝
了与变量相联系的属性、维和坐标变量。

维名称赋值
^^^^^^^^^^^^^^
给一个已经定义的变量或文件变量赋值维名称，使用以下模型::

    变量名!维序号 = 新的名称

这一操作将新的名称赋值到与维序号相对应的变量的维。

例：::

    a!0 = "Dimension1"
    thefile->a!0 = "Dimension1"

坐标变量赋值
^^^^^^^^^^^^^


属性赋值
^^^^^^^^^^^^^^

重新赋值语句
--------------

外部程序
--------------

可视化代码段
--------------

载入共享库
--------------
``external`` 命令载入共享库对象。共享库被用于扩展NCL去调用C和
Fortran函数或子程序。其语法是::

    external string_name path_name



从文件载入脚本
---------------
``load`` 命令被用于载入外部的脚本文件。这些外部脚本既可以是函数和
子程序集，也可以是NCL程序。当前， ``file_path``  必须是常数值，
字符串表达式将触发语法错误信息。你可以将 ``load`` 命令想象成C语言
中的 ``#include`` 。执行到 ``load`` 命令时，将立即执行，而不能被
条件执行。::

    load "file_path"

为了条件执行一个脚本或使用引用文件路径的字符串变量，使用
``loadscript`` 子程序。
    


record命令
---------------
``record`` 命令将对命令行会话中所有语法正确的命令被保存在
``file_path``  常量字符串所指定的文件中。 ``stop record`` 
命令终止这一过程。::

    record "file_path"
    statements
    . . .
    stop record


退出NCL交互式会话或脚本
------------------------
``quit`` 命令立即退出NCL交互式会话或脚本。与 ``load`` 命令一致，
在执行到其时，被立即执行而不能被条件执行。在关闭前，NCL将会安全
的关闭任何已经打开的图形或数据文件。

为了条件退出一个脚本，使用 ``exit`` 和 ``status_exit`` 子程序。


.. disqus::
    :disqus_identifier: first_map